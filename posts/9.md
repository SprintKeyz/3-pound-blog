---
title: "Building the Controller"
date: "17 November 2025"
week: 9
---

This week I built my controller. Throughout the build and design process, I had a few realizations that I probably should've had earlier, but I'll get to those. The first thing I did was create a design for the wristband, going off measurements of my wrist. However, I quickly saw two issues: the battery made the wristband thick, and I had to factor in the diameter of my knuckles in order to be able to put on the wristband. In the end, this was my design with the battery:

![Wristband CAD](/images/9-1.png "width=50%")

Unfortunately, after fabricating this design and trying it on, it became quite apparent that it looked ridiculous. This image is just the top piece, yet it gives an idea of the diameter.

![Wristband](/images/9-2.jpg "width=50%")

While I could make it smaller, I decided that in a best case scenario the band would still be too large, so I went back to the drawing board. As I've learned in the past, the best solution is often the simplest one, as was the case here. I modeled a simple controller that fits everything together nicely and can be held in the palm of a hand.

![controller](/images/9-3.png "width=40%") 
![controller](/images/9-4.png "width=40%") 

After assembling the controller, I'm proud to say it turned out well. It includes a battery, a gyroscope + accelerometer module that tracks tilt in space, and a microcontroller with wifi and bluetooth support for communication as I planned. This was my final product:

*note: it should be held horizontally, I just held it vertically because I hadn't taped it shut*

![pcb](/images/9-5.jpg "width=80%") 
![controller](/images/9-6.jpg "width=50%") 

The final step for the controller was to program it. Unfortunately for me, the accelerometer and gyroscope chip I was using wasn't very popular, and thus had no pre-made code examples I could modify. I *did*, however, manage to find a datasheet with entries that looked something like this for 102 pages:

![controller](/images/9-7.png "width=70%") 

Though it looks complicated, this isn't actually too difficult to work with once you understand how these chips work at their core. Virtually all computer chips use something called "registers", which are sections of memery that store data that can be read to, written to, or both. Based on what's in these sections of memory, these chips then know to perform certain functions. In our case, we want to read and write to the registers that tell us our acceleration and tilt values. This sensor communicates over a very common two wire protocol called IÂ²C, so the code to do this is somewhat simple. After some setup of reading and writing to registers, all it takes to read the accleration, for example, is this code:

```cpp
int16_t data[3];

if (!readRegisters(LSM6DS3_OUTX_L_XL, (uint8_t*)data, sizeof(data))) {
    x = NAN;
    y = NAN;
    z = NAN;

    return 0;
}

x = data[0] * 4.0 / 32768.0;
y = data[1] * 4.0 / 32768.0;
z = data[2] * 4.0 / 32768.0;
```

This tells our code to read the section of memory where the sensor stores our acceleration and send it to our microcontroller, where we can do whatever we want with it. For example, we can send it to a dashboard wirelessly to graph our acceleration in G's.

![graph](/images/9-8.png "width=70%") 

Using this data plus data from the gyroscope, we can successfully determine our tilt angle! Now, we just have to assemble and communicate this to our robot.